#### Q：Redis有多少个数据库？
#### A：Redis默认有16个数据库。

---

#### Q：Redis单线程为什么这么快？
#### A：Redis是将所有数据存在内存中的，所以说使用单线程去操作的效率就是最高的，多线程操作时，CPU会进行上下文切换，耗时，对于内存系统来说，没有上下文切换效率就是最高的。

---

#### Q：Redis事务

#### A：Redis单条命令保证原子性，Redis事务不保证原子性。事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。

---

#### Q：Redis乐观锁

#### A：可以使用WATCH命令实现乐观锁。被WATCH的键会被监视，并会发觉这些键是否被改动过。如果至少有一个被监视的键在EXEC执行之前被修改了，那么整个事务都会取消。

---

#### Q：Redis持久化

#### A：有RDB和AOF两种方式，默认开启的是RDB。如果RDB和AOF同时开启，Redis会优先读取AOF文件。

##### RDB：

* 实现方式：

  ​		Redis从master主进程先fork出一个子进程，使用写时复制机制，子进程将内存的数据写入到一个临时文件中，当数据写入完成之后再将上一次保存的RDB文件替换掉，然后关闭子进程，这样可以保证每一次做RDB快照保存的数据都是完整的。

* 配置方式：

    ​		在配置文件中，添加 **save \<seconds\> \<changes\>** 配置。这个配置是说在 **\<seconds\>** 秒内，至少有 **\<changes\>** 个key被修改了，就会把这些key写到硬盘中。

* 优点：

    * 执行速度较快；
    * 在恢复大数据集时，会比AOF快；
    
* 缺点：

    * 可能会导致某段时间内的数据丢失（取决于配置的save）；
    * 每次保存的时候，Redis都要fork出一个子进程，在数据集比较庞大的时候，fork可能会非常耗时；

##### AOF：

* 实现方式：

  ​		所有写入的命令追加到AOF缓冲区，AOF根据设置的fsync策略向硬盘做同步操作。Redis会定期对AOF文件进行重写。

* AOF重写：

  ​		Redis从master主进程先fork除一个子进程，使用写时复制机制，子进程将新的AOF文件的内容写入到一个临时文件中，对于所有新执行的写入命令，主进程一边将他们积累到一个内存缓存中，一边将这些改动追加到现有AOF文件的末尾：这样即使在重写的中途发生停机，现有的AOF文件也还是安全的。当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新AOF文件的末尾。然后Redis会用新文件替换旧文件，之后所有命令都会直接追加到新AOF文件的末尾。

* 配置方式：

    ​		在配置文件中，把 **appendonly** 项设置成 **yes**。

* 优点：

    * 可以最大程度保持数据的完整性；
    * Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。
    
* 缺点：

    * 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。
    * 根据fsync策略的不同，速度可能会比RDB慢。

---

#### Q：Redis主从复制

#### A：

*   复制流程：
    *   无论是初次连接还是重新连接，当建立一个从服务器时，从服务器都将向主服务器发送一个SYNC命令。
    *   接到SYNC命令的主服务器将开始执行BGSAVE，并在保存操作执行期间，将所有新执行的写入命令都保存到一个缓冲区里面。
    *   当BGSAVE执行完毕后，主服务器将执行保存操作所得的 `.rdb` 文件发送给从服务器，从服务器接收这个 `.rdb` 文件，并将文件中的数据载入到内存中。
    *   之后主服务器会以 Redis 命令协议的格式，将写命令缓冲区中积累的所有内容都发送给从服务器。

---

#### Q：Redis哨兵模式（Sentinel）

#### A：

*   作用：
    *   监控：哨兵会不断的检查主服务器和从服务器是否正常运行。
    *   提醒：当被监控的某个Redis服务器出现问题时，哨兵可以通过API向管理员或其他程序发送通知。
    *   自动故障迁移：当一个主服务器不能正常工作时，哨兵会将失效的主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器。

---

#### Q：Redis中key的过期策略

#### A：

---

#### Q：缓存穿透

#### A：

*   问题描述：用户不断请求一个缓存和数据库中都不存在的数据，导致数据库压力过大。
*   解决方案：
    *   缓存一个空值，可以防止反复访问数据库。
    *   布隆过滤器。将所有可能的查询条件通过多个不同的哈希函数生成多个哈希值，并将对应哈希值指向的bit位置的值设置成1，当查询进来的时候，通过哈希函数计算哈希值，如果存在哈希值对应的bit位上的值为0，说明要查询的数据不存在。

---

#### Q：缓存击穿

#### A：

*   问题描述：大量用户同时访问一个缓存中不存在，数据库中存在的数据（如某热点数据），导致数据库压力过大。
*   解决方案
    *   设置热点数据不过期。
    *   加互斥锁，第一个进入的请求获取锁并从数据库中获取数据写入缓存中，其他的请求等待，然后再去缓存中获取数据。

---

#### Q：缓存雪崩

#### A：

*   问题描述：大量缓存在同一时间过期，所有请求直接访问数据库，导致数据库压力过大。

*   解决方案
    *   数据预热。
    *   设置不同的过期时间，防止缓存同一时间过期。

